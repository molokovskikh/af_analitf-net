import Boo.Lang.PatternMatching
import System
import System.Collections
import System.Reflection
import System.IO
import System.Net.Mail
import System.Xml
import System.Xml.Linq
import System.Linq.Enumerable
import System.Xml.XPath.Extensions
import System.Net
import System.Text
import System.Threading
import Mono.Cecil

def FileElement(file as string, id as string, element as XElement):
	return XElement(element.Name.Namespace + "File", XAttribute("Id", id), XAttribute("Source", Path.GetFullPath(file)))

def AddDirectory(id as string, path as string, document as XDocument, manager as XmlNamespaceManager):
	element = document.XPathSelectElement("/prefix:Wix/prefix:Fragment/prefix:DirectoryRef[@Id='$id']/prefix:Component", manager)
	for file in Directory.GetFiles(path):
		fileId = Path.GetFileName(file) + "_" + id
		element.Add(FileElement(file, fileId, element))

	for dir in Directory.GetDirectories(path):
		id = Path.GetFileName(dir)
		AddDirectory(id, dir, document, manager)

def RegisterApp(iishost as object, sitename as string, path as string, fspath as string, pool as string):
	hosts = iishost as ICollection or (iishost, )
	script = Path.GetFullPath("scripts/iis.ps1")
	hostsArg = join(hosts, ",")
	psArgs = ""
	if Globals.Environment == @Production:
		user, password = AskCredentials("user for $hostsArg:")
		psArgs = "-Credential (New-Object PsCredential('$user', (convertto-securestring '$password' -asplaintext -force)))"
	Exec("powershell", "Invoke-Command -ComputerName $hostsArg -FilePath $script -ArgumentList $path,$sitename,$fspath,$pool $psArgs").Execute()

def CopyUpdateBin(channel as string):
	dir = Path.Combine(Path.GetDirectoryName(Globals.UpdateDeployRoot), channel)
	if Exist(dir):
		Rm("$dir/*")
	else:
		MkDir(dir)
	impersonate = Configuration.Maybe.impersonate != null
	if impersonate:
		ImpersonateUser("deployer", '$sdfsd887!'):
			Cp("output/updater/*", dir, true)
	else:
		Cp("output/updater/*", dir, true)

Global(
#	Project: "src/service/app/app.csproj",
	HumanReadableName: "AnalitF.Net",
	Profile: @catalog,
	Variables : {
		@Local: {
			@UpdateDeployRoot: """C:\inetpub\wwwroot\AnalitF.Net.Service-0.9.7.35\var\update\rtm""",
			@CheckUrlRoot: "http://localhost/AnalitF.Net.Service",
			@IISSiteName: "local",
			@IISHost: "localhost",
			@IISAppPool: "DefaultAppPool"
		},
		@Production : {
			@UpdateDeployRoot: """\\acdcserv\WebApps\var\update\alpha""",
			@CheckUrlRoot: "http://ios.analit.net/AnalitF.Net.Service",
			@IISSiteName: "IOS",
			@IISHost: ("solo", "frontrmt"),
			@IISPathRoot: "U:\\WebApps",
			@IISAppPool: "Runer"
		},
		@Test : {
			@DeployRoot: """\\acdcserv\TEST""",
			@DeployAlias: "AnalitF.Net.Service.Test",
			@UpdateDeployRoot: """\\acdcserv\TEST\var-test\update\rtm""",
			@CheckUrlRoot: "http://test.analit.net/AnalitF.Net.Service",
			@IISSiteName: "TEST",
			@IISHost: "acdcserv"
		}
	},
	JenkinsProject: "AnalitF.Net",
	Retarget: true
)

task @default, [@build]

task @build, ["build:service", "build:client"]

task @prepare, ["env", "packages:install", "packages:fix", "generate:assembly:info"]

task "build:service", ["prepare"]:
	CleanWeb(Globals, "src/service/app/app.csproj")
	BuildWeb(Globals, "src/service/app/app.csproj")

task "deploy:service", ["build:service"]:
	proj = "src/service/app/app.csproj"
	name, output, _ = GetBuildConfig(Globals, proj)

	bin = FileSet("**/$name.dll", BaseDirectory: output).First()
	assembly = AssemblyDefinition.ReadAssembly(bin)
	version = assembly.Name.Version.ToString()

	deployTo = GetDeploy(Globals, proj)
	deployTo += "-$version"
	name += "-$version"
	Globals.CheckUrl = Globals.CheckUrlRoot + "-$version/Status/"
	MkDir(deployTo) unless Exist(deployTo)
	deployToBin = Path.Combine(deployTo, "bin")
	deployToVar = Path.Combine(deployTo, "var")
	MkDir(deployToBin) unless Exist(deployToBin)
	MkDir(deployToVar) unless Exist(deployToVar)
	XCopyDeploy(Globals, proj, deployToBin)
	fsPath = Path.GetFullPath(deployToBin)
	if Globals.Maybe.IISPathRoot:
		fsPath = Path.Combine(Globals.IISPathRoot, name, "bin")
	RegisterApp(Globals.IISHost, Globals.IISSiteName, name, fsPath, Globals.Maybe.IISAppPool)

	#создаем маршрут в прокси
	deployTo = Path.Combine(GetDeploy(Globals, "proxy"), "var")
	proxyConfig = Path.Combine(deployTo, @config)
	using writer = StreamWriter(proxyConfig, true):
		writer.WriteLine("$version " + Globals.CheckUrlRoot + "-$version")

task "build:proxy", ["prepare"]:
	CleanWeb(Globals, "src/proxy/app/app.csproj")
	BuildWeb(Globals, "src/proxy/app/app.csproj")

task "deploy:proxy", ["build:proxy"]:
	proj = "src/proxy/app/app.csproj"
	name, output, _ = GetBuildConfig(Globals, proj)
	deployTo = GetDeploy(Globals, proj)
	deployToBin = Path.Combine(deployTo, "bin")
	deployToVar = Path.Combine(deployTo, "var")
	MkDir(deployToBin) unless Exist(deployToBin)
	MkDir(deployToVar) unless Exist(deployToVar)
	XCopyDeploy(Globals, proj, deployToBin)
	fsPath = Path.GetFullPath(deployToBin)
	unless Configuration.Maybe.skipRegister:
		if Globals.Maybe.IISPathRoot:
			fsPath = Path.Combine(Globals.IISPathRoot, name, "bin")
		RegisterApp(Globals.IISHost, Globals.IISSiteName, name, fsPath, Globals.Maybe.IISAppPool)

task @deploy, ["env", "git:tag", "prepare", "check", "build", "db:migrate", "deploy:service", "deploy:client", "deploy:update", "test:binary", "deploy:notify", "git:push:tags"]

task "deploy:client", ["deploy:client:package"]

task "deploy:client:package", ["build:client:package"]:
	impersonate = Configuration.Maybe.impersonate != null
	if impersonate:
		ImpersonateUser("deployer", '$sdfsd887!'):
			Cp("output/package/*.nupkg", "//offdc/MMedia/packages", true)
	else:
		Cp("output/package/*.nupkg", "//offdc/MMedia/packages", true)

task "build:client:package", ["build:client"]:
	proj = "src/client/app/app.csproj"
	name, output, _ = GetBuildConfig(Globals, proj)
	bin = FileSet("*.exe", BaseDirectory: output).First()

	assembly = AssemblyDefinition.ReadAssembly(bin)
	version = assembly.Name.Version.ToString()
	build = Configuration.Maybe.buildId
	if build:
		version += "-build" + build
	RmDir("output/package", true)
	MkDir("output/package")
	MkDir("output/package/tools")
	Cp("output/setup/setup.exe", "output/package/tools/analitf.net.setup.exe", true)
	Cp(FileSet("**.*", BaseDirectory: output), "output/package/tools/", true)
	spec = "output/package/analitf.net.nuspec"
	Cp("assets/package.nuspec", spec)
	specDoc = XDocument.Load(spec)
	versionNode = specDoc.Descendants().First({n| n.Name.LocalName == "version"})
	versionNode.Value = version
	specDoc.Save(spec)
	Exec("cmd.exe", "/C choco pack", BaseDirectory: "output/package").Execute()

task "deploy:update", ["build:client"]:
	dir = Globals.UpdateDeployRoot
	if Exist(dir):
		Rm("$dir/*")
	else:
		MkDir(dir)
	impersonate = Configuration.Maybe.impersonate != null
	if impersonate:
		ImpersonateUser("deployer", '$sdfsd887!'):
			Cp("output/updater/*", dir, true)
	else:
		Cp("output/updater/*", dir, true)

task "build:client", ["env", "build:client:bin", "build:setup", "build:update"]

task "build:client:bin":
	proj = "src/client/app/app.csproj"
	name, output, _ = GetBuildConfig(Globals, proj)
	Clean(Globals, proj)
	Build(Globals, proj)
	Cp(FileSet("**", BaseDirectory: "lib/libmysqld", Excludes: ["build.sh", ".gitignore"]), output)
	Rm(FileSet("$output/*.xml"))
	if Globals.Environment == @Production:
		Rm(FileSet("$output/*.pdb"))

task "build:setup":
	arg = ""
	if Globals.Environment != @Production:
		arg = "--quiet"
	Bash("./scripts/wix.sh $arg")

task "setup:preprocess":
	proj = "src/client/app/app.csproj"
	name, output, _ = GetBuildConfig(Globals, proj)
	bin = FileSet("*.exe", BaseDirectory: output).First()

	assembly = AssemblyDefinition.ReadAssembly(bin)
	File.WriteAllText("output/setup/version.txt", assembly.Name.Version.ToString())
	name = "output/setup/files.wxs"
	document = XDocument.Load(name)
	manager = XmlNamespaceManager(NameTable())
	manager.AddNamespace("prefix", "http://schemas.microsoft.com/wix/2006/wi")

	AddDirectory("INSTALLFOLDER", output, document, manager)
	document.Save(name)
	Cp("assets/Демонстрационная дефектура.csv", "output/setup/")

task "build:update":
	_, clientOutput, _ = GetBuildConfig(Globals, "src/client/app/app.csproj")
	_, updaterOutput, _ = GetBuildConfig(Globals, "src/updater/app/app.csproj")
	Clean(Globals, "src/updater/app/app.csproj")
	Build(Globals, "src/updater/app/app.csproj")
	Cp("output/setup/version.txt", updaterOutput, true)
	Cp("$clientOutput/*", updaterOutput, true)
	Rm(FileSet("$updaterOutput/*.xml"))
	if Globals.Environment == @Production:
		Rm(FileSet("$updaterOutput/*.pdb"))

task "git:push:tags":
	return unless Globals.Environment == @Production
	Bash("git push --tags")

task "git:tag":
	return unless Globals.Environment == @Production

	kind = Configuration.Maybe.kind
	unless kind:
		raise "Нужно указать тип релиза kind=patch - исправление ошибок, kind=minor - новый функционал, kind=major - координальные изменения в существующем функционале, подробней о версионности http://semver.org"

	output = ExecuteProcess("git", "log -1 --decorate --pretty=oneline")
	if output.Contains("tag: v"):
		print "Последний коммит был релизом, не буду обновлять номер версии тк похоже что это на повторный деплой"
		return

	currentVersion = GetVersionTags().LastOrDefault() or Version(GetVersion())
	revision = currentVersion.Revision
	if revision == -1:
		revision = 0
	revision++
	major = currentVersion.Major
	minor = currentVersion.Minor
	build = currentVersion.Build
	match kind:
		case "patch":
			build++
		case "minor":
			minor++
		case "major":
			major++
		otherwise:
			raise "Не знаю что за релиз $kind"
	newVersion = Version(major, minor, build, revision)
	Bash("git tag v$newVersion")

task "test:binary":
	return unless Globals.Environment == @Production
	try:
		testId = "26307"
		testPassword = "TkGJEQUX"
		unless Globals.Maybe.CheckUrl:
			proj = "src/service/app/app.csproj"
			name, output, _ = GetBuildConfig(Globals, proj)
			bin = FileSet("**/$name.dll", BaseDirectory: output).First()
			assembly = AssemblyDefinition.ReadAssembly(bin)
			version = assembly.Name.Version.ToString()
			Globals.CheckUrl = Globals.CheckUrlRoot + "-$version/Status/"
		proj = "src/service/app/app.csproj"
		name, output, _ = GetBuildConfig(Globals, proj)

		bin = FileSet("**/$name.dll", BaseDirectory: output).First()
		assembly = AssemblyDefinition.ReadAssembly(bin)
		version = assembly.Name.Version.ToString()
		done = false
		count = 0
		while not done:
			try:
				count++
				if count > 20:
					raise "Не удалось дождаться версии $version"
				using client = WebClient():
					client.Credentials = NetworkCredential(testId, testPassword)
					serviceVersion = client.DownloadString(Globals.CheckUrl)
					done = serviceVersion == version
				unless done:
					print "Для сервиса ${Global.CheckUrl} ожидаю версию $version получил $serviceVersion"
					print "Жду обновления"
					Thread.Sleep(1000)
			except e:
				if count > 20:
					raise
				print e.Message
				print "Жду обновления"
				Thread.Sleep(1000)
		Db.Execute("update Customers.AnalitFNetDatas set BinUpdateChannel = 'alpha' where UserId = $testId")
		Sh("nunit-console-x86 /nologo /run test.release.AppFixture ./src/client/test.release/bin/Debug/test.release.dll")
		CopyUpdateBin("beta")
	except:
		print "Похоже что есть проблемы с релизом, автоматическое обновление отключено, исправь ошибки и повтори релиз, возможно следует удалить тег релиза"
		raise

task "deploy:setup":
	url = "http://redmine.analit.net/projects/afn/versions.json"
	version = File.ReadAllText("output/setup/version.txt")
	client = WebClient()
	client.Headers.Add(HttpRequestHeader.ContentType, "application/json")
	client.Headers.Add("X-Redmine-API-Key", "778ed542c36c919a58c9fa62615e3096b0761a42")
	try:
		client.UploadString(url, "{ \"version\": {\"name\": \"$version\" } }")
	except e:
		print e
	Cp("output/setup/setup.exe", """\\adc.analit.net\Inforoom\FTP\anonymous\AnalitFNET_0_9_0_28.exe""", true)
	Cp("output/setup/setup.exe", """\\adc.analit.net\Inforoom\FTP\anonymous\AnalitFNET.exe""", true)
	CopyUpdateBin("rtm")

task "iis:clean":
	iishost = Globals.IISHost
	hosts = iishost as ICollection or (iishost, )
	sitename = Globals.IISSiteName
	hostsArg = join(hosts, ",")
	psArgs = ""
	if Globals.Environment == @Production:
		user, password = AskCredentials("user for $hostsArg:")
		psArgs = "-Credential (New-Object PsCredential('$user', (convertto-securestring '$password' -asplaintext -force)))"
	Exec("powershell", "Invoke-Command -ComputerName $hostsArg $psArgs -ScriptBlock {Remove-WebApplication -site $sitename Analitf.Net.Proxy}").Execute()
	Exec("powershell", "Invoke-Command -ComputerName $hostsArg $psArgs -ScriptBlock {Remove-WebApplication -site $sitename AnalitF.Net.Service-0.9.7.35}").Execute()
