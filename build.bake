import Boo.Lang.PatternMatching
import System
import System.Collections
import System.Reflection
import System.IO
import System.Net.Mail
import System.Xml
import System.Xml.Linq
import System.Linq.Enumerable
import System.Xml.XPath.Extensions
import System.Net
import System.Text
import System.Threading
import System.Resources
import Mono.Cecil
import Newtonsoft.Json

def FileElement(file as string, id as string, element as XElement):
	return XElement(element.Name.Namespace + "File", XAttribute("Id", id), XAttribute("Source", Path.GetFullPath(file)))

def AddDirectory(id as string, path as string, document as XDocument, manager as XmlNamespaceManager):
	element = document.XPathSelectElement("/prefix:Wix/prefix:Fragment/prefix:DirectoryRef[@Id='$id']/prefix:Component", manager)
	for file in Directory.GetFiles(path):
		if String.Equals(Path.GetExtension(file), ".pdb", StringComparison.OrdinalIgnoreCase):
			continue
		fileId = Path.GetFileName(file) + "_" + id
		element.Add(FileElement(file, fileId, element))

	for dir in Directory.GetDirectories(path):
		id = Path.GetFileName(dir)
		AddDirectory(id, dir, document, manager)

def RegisterApp(iishost as object, sitename as string, path as string, fspath as string, pool as string):
	hosts = iishost as ICollection or (iishost, )
	script = Path.GetFullPath("scripts/iis.ps1")
	hostsArg = join(hosts, ",")
	psArgs = ""
	if Globals.Environment == @Production:
		user, password = AskCredentials("user for $hostsArg:")
		psArgs = "-Credential (New-Object PsCredential('$user', (convertto-securestring '$password' -asplaintext -force)))"
	Exec("powershell", "Invoke-Command -ComputerName $hostsArg -FilePath $script -ArgumentList $path,$sitename,$fspath,$pool $psArgs").Execute()

def CopyUpdateBin(channel as string):
	dir = Globals.UpdateDeployRoot
	MkDir(dir) unless Exist(dir)
	dir = Path.Combine(dir, channel)
	if Exist(dir):
		Rm("$dir/*")
	else:
		MkDir(dir)
	impersonate = Configuration.Maybe.impersonate != null
	files = FileSet("*", BaseDirectory: "output/updater/", Excludes: ["*.pdb", ])
	if impersonate:
		ImpersonateUser("deployer", '$sdfsd887!'):
			Cp(files, dir, true)
	else:
		Cp(files, dir, true)

Global(
	HumanReadableName: "AnalitF.Net",
	Profile: @catalog,
	Variables : {
		@Local: {
			@UpdateDeployRoot: """C:\inetpub\wwwroot\data\update\""",
			@DefaultUpdateChannel: "rtm",
			@CheckUrlRoot: "http://localhost/AnalitF.Net.Service",
			@IISSiteName: "local",
			@IISHost: "localhost",
			@IISAppPool: "DefaultAppPool"
		},
		@Test : {
			@DeployAlias: "AnalitF.Net.Service.Test",
			@UpdateDeployRoot: """\\acdcserv\TEST\var-test\update\""",
			@DefaultUpdateChannel: "rtm",
			@CheckUrlRoot: "http://test.analit.net/AnalitF.Net.Service",
			@IISSiteName: "TEST",
			@IISHost: "acdcserv"
		},
		@Production : {
			@UpdateDeployRoot: """\\acdcserv\WebApps\var\update\""",
			@DefaultUpdateChannel: "alpha",
			@SetupDeployRoot: """\\offdc\MMedia\AnalitF.Net""",
			@CheckUrlRoot: "http://ios.analit.net/AnalitF.Net.Service",
			@IISSiteName: "IOS",
			@IISHost: ("solo", "frontrmt"),
			@IISPathRoot: "U:\\WebApps",
			@IISAppPool: "Runer"
		},
	},
	JenkinsProject: "AnalitF.Net",
	Retarget: true,
	AdditionalAssemblies: ("src/service/app/bin/AnalitF.Net.Service.dll", )
)

task @default, [@build]

task @build, ["build:service", "build:client"]

task @prepare, ["packages:install", "packages:fix", "generate:assembly:info"]

task "build:service", ["prepare"]:
	CleanWeb(Globals, "src/service/app/app.csproj")
	BuildWeb(Globals, "src/service/app/app.csproj")

task "deploy:service", ["build:service"]:
	proj = "src/service/app/app.csproj"
	name, output, _ = GetBuildConfig(Globals, proj)

	bin = FileSet("**/$name.dll", BaseDirectory: output).First()
	assembly = AssemblyDefinition.ReadAssembly(bin)
	version = assembly.Name.Version.ToString()

	deployTo = GetDeploy(Globals, proj)
	deployTo += "-$version"
	name += "-$version"
	Globals.CheckUrl = Globals.CheckUrlRoot + "-$version/Status/"
	MkDir(deployTo) unless Exist(deployTo)
	deployToBin = Path.Combine(deployTo, "bin")
	deployToVar = Path.Combine(deployTo, "var")
	MkDir(deployToBin) unless Exist(deployToBin)
	MkDir(deployToVar) unless Exist(deployToVar)
	XCopyDeploy(Globals, proj, deployToBin)
	fsPath = Path.GetFullPath(deployToBin)
	if Globals.Maybe.IISPathRoot:
		fsPath = Path.Combine(Globals.IISPathRoot, name, "bin")
	RegisterApp(Globals.IISHost, Globals.IISSiteName, name, fsPath, Globals.Maybe.IISAppPool)

	#создаем маршрут в прокси
	deployTo = Path.Combine(GetDeploy(Globals, "proxy"), "var")
	proxyConfig = Path.Combine(deployTo, @config)
	using writer = StreamWriter(proxyConfig, true):
		writer.WriteLine("$version " + Globals.CheckUrlRoot + "-$version")

task "build:proxy", ["prepare"]:
	CleanWeb(Globals, "src/proxy/app/app.csproj")
	BuildWeb(Globals, "src/proxy/app/app.csproj")

task "deploy:proxy", ["build:proxy"]:
	proj = "src/proxy/app/app.csproj"
	name, output, _ = GetBuildConfig(Globals, proj)
	deployTo = GetDeploy(Globals, proj)
	deployToBin = Path.Combine(deployTo, "bin")
	deployToVar = Path.Combine(deployTo, "var")
	MkDir(deployToBin) unless Exist(deployToBin)
	MkDir(deployToVar) unless Exist(deployToVar)
	XCopyDeploy(Globals, proj, deployToBin)
	fsPath = Path.GetFullPath(deployToBin)
	unless Configuration.Maybe.skipRegister:
		if Globals.Maybe.IISPathRoot:
			fsPath = Path.Combine(Globals.IISPathRoot, name, "bin")
		RegisterApp(Globals.IISHost, Globals.IISSiteName, name, fsPath, Globals.Maybe.IISAppPool)

task @deploy, ["env", "git:tag", "prepare", "check", "build", "db:migrate", "deploy:service", "deploy:client", "deploy:update", "test:binary", "deploy:notify", "deploy:announce", "git:push:tags"]

task "deploy:client", ["deploy:client:package"]

task "deploy:client:package", ["build:client:package"]:
	impersonate = Configuration.Maybe.impersonate != null
	if impersonate:
		ImpersonateUser("deployer", '$sdfsd887!'):
			Cp("output/package/*.nupkg", "//offdc/MMedia/packages", true)
	else:
		Cp("output/package/*.nupkg", "//offdc/MMedia/packages", true)

task "build:client:package", ["build:client"]:
	proj = "src/client/app/app.csproj"
	name, _, _ = GetBuildConfig(Globals, proj)
	output = "output/merged"
	bin = FileSet("*.exe", BaseDirectory: output).First()

	assembly = AssemblyDefinition.ReadAssembly(bin)
	version = assembly.Name.Version.ToString()
	build = Configuration.Maybe.buildId
	if build:
		version += "-build" + build
	RmDir("output/package", true)
	MkDir("output/package")
	MkDir("output/package/tools")
	Cp("output/setup/setup.exe", "output/package/tools/analitf.net.setup.exe", true)
	Cp(FileSet("**.*", BaseDirectory: output), "output/package/tools/", true)
	spec = "output/package/analitf.net.nuspec"
	Cp("assets/package.nuspec", spec)
	specDoc = XDocument.Load(spec)
	versionNode = specDoc.Descendants().First({n| n.Name.LocalName == "version"})
	versionNode.Value = version
	specDoc.Save(spec)
	Exec("cmd.exe", "/C choco pack", BaseDirectory: "output/package").Execute()

task "deploy:update", ["build:update"]:
	CopyUpdateBin(Globals.DefaultUpdateChannel)

task "build:client", ["env", "build:client:bin", "build:setup", "build:update"]

task "build:client:bin":
	proj = "src/client/app/app.csproj"
	name, output, _ = GetBuildConfig(Globals, proj)
	Clean(Globals, proj)
	Build(Globals, proj)
	Cp(FileSet("**", BaseDirectory: "lib/libmysqld", Excludes: ["src", "build.sh", ".gitignore"]), output)
	Rm(FileSet("$output/*.xml"))

def CopyResource(res as EmbeddedResource, writer as ResourceWriter):
	reader = ResourceReader(res.GetResourceStream())
	for item in reader:
		writer.AddResource(item.Key, item.Value)

task "build:client:merged", ["build:client:bin"]:
	_, source, _ = GetBuildConfig(Globals, "src/client/app/app.csproj")
	output = "output/merged"
	RmDir(output, true) if Exist(output)
	while Exist(output):
		Thread.Sleep(10)
	MkDir(output)
	files = String.Join(" ", FileSet(["*.dll", "*.exe"], BaseDirectory: source, Excludes: ["libmysqld.dll", ]))
	exe = FileSet("*.exe", BaseDirectory: source).First()
	name = Path.Combine(output, Path.GetFileName(exe))
	Sh("ilmerge /targetplatform:v4,\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.0\" $files /allowdup /out:$name")
	Cp(FileSet("**", BaseDirectory: "lib/libmysqld", Excludes: ["src", "build.sh", ".gitignore"]), output)
	Cp(FileSet("*.config", BaseDirectory: source), output)
	#тк мы обединили сборки библиотки содержащие wpf контролы не найдут свои ресурсы правим это
	outputAssembly = AssemblyDefinition.ReadAssembly(name)
	resources = outputAssembly.MainModule.Resources
	appBaml = resources.OfType[of EmbeddedResource]().First({x| x.Name == "AnalitF.Net.Client.g.resources"})
	libBaml = resources.OfType[of EmbeddedResource]().First({x| x.Name == "Xceed.Wpf.Toolkit.g.resources"})
	memory = MemoryStream()
	writer = ResourceWriter(memory)
	CopyResource(appBaml, writer)
	CopyResource(libBaml, writer)
	writer.Generate()
	resources.Remove(appBaml)
	resources.Remove(libBaml)
	memory.Position = 0
	resources.Add(EmbeddedResource(appBaml.Name, ManifestResourceAttributes.Public, memory))
	outputAssembly.Write(name)

task "build:setup", ["build:client:merged"]:
	arg = ""
	if Globals.Environment != @Production:
		arg = "--quiet"
	Bash("./scripts/wix.sh $arg")

task "setup:preprocess":
	proj = "src/client/app/app.csproj"
	name, _, _ = GetBuildConfig(Globals, proj)
	output = "output/merged"
	bin = FileSet("*.exe", BaseDirectory: output).First()

	assembly = AssemblyDefinition.ReadAssembly(bin)
	File.WriteAllText("output/setup/version.txt", assembly.Name.Version.ToString())
	name = "output/setup/files.wxs"
	document = XDocument.Load(name)
	manager = XmlNamespaceManager(NameTable())
	manager.AddNamespace("prefix", "http://schemas.microsoft.com/wix/2006/wi")

	AddDirectory("INSTALLFOLDER", output, document, manager)
	document.Save(name)
	Cp("assets/Демонстрационная дефектура.csv", "output/setup/")

task "build:update", ["build:client:merged"]:
	clientOutput = "output/merged"
	_, updaterOutput, _ = GetBuildConfig(Globals, "src/updater/app/app.csproj")
	Clean(Globals, "src/updater/app/app.csproj")
	Build(Globals, "src/updater/app/app.csproj")
	merged = FileSet(["*.exe", "*.dll"], BaseDirectory: updaterOutput)
	files = String.Join(" ", merged.OrderByDescending({f|f.IndexOf(".exe")}))
	exe = merged.First({f| Path.GetExtension(f) == ".exe"})
	MkDir("output/updater/merged") unless Exist("output/updater/merged")
	name = Path.Combine(Path.GetDirectoryName(exe), "merged", Path.GetFileName(exe))
	Sh("ilmerge /targetplatform:v4,\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.0\" $files /allowdup /out:$name")
	for f in merged.Concat(merged.Select({f| Path.ChangeExtension(f, ".pdb")})):
		Rm(f)
	Mv(name, exe)
	Mv(Path.ChangeExtension(name, ".pdb"), Path.ChangeExtension(exe, ".pdb"))
	#файл маркер для удаления старых бинарников
	File.WriteAllText(Path.Combine(updaterOutput, "delete.me"), "*.exe\r\n*.dll\r\n*.pdb")

	Cp("output/setup/version.txt", updaterOutput, true)
	Cp(FileSet("*", BaseDirectory: clientOutput), updaterOutput, true)
	Rm(FileSet("*.xml", BaseDirectory: updaterOutput))

task "git:push:tags":
	return unless Globals.Environment == @Production
	Bash("git push --tags")

task "git:tag":
	return unless Globals.Environment == @Production

	kind = Configuration.Maybe.kind
	unless kind:
		raise "Нужно указать тип релиза kind=patch - исправление ошибок, kind=minor - новый функционал, kind=major - координальные изменения в существующем функционале, подробней о версионности http://semver.org"

	output = ExecuteProcess("git", "log -1 --decorate --pretty=oneline")
	if output.Contains("tag: v"):
		print "Последний коммит был релизом, не буду обновлять номер версии тк похоже что это на повторный деплой"
		return

	currentVersion = GetVersion()
	revision = currentVersion.Revision
	if revision == -1:
		revision = 0
	revision++
	major = currentVersion.Major
	minor = currentVersion.Minor
	build = currentVersion.Build
	match kind:
		case "patch":
			build++
		case "minor":
			build = 0
			minor++
		case "major":
			build = 0
			minor = 0
			major++
		otherwise:
			raise "Не знаю что за релиз $kind"
	newVersion = Version(major, minor, build, revision)
	Bash("git tag v$newVersion")

task "test:binary":
	return unless Globals.Environment == @Production
	try:
		testId = "26307"
		testPassword = "TkGJEQUX"
		unless Globals.Maybe.CheckUrl:
			proj = "src/service/app/app.csproj"
			name, output, _ = GetBuildConfig(Globals, proj)
			bin = FileSet("**/$name.dll", BaseDirectory: output).First()
			assembly = AssemblyDefinition.ReadAssembly(bin)
			version = assembly.Name.Version.ToString()
			Globals.CheckUrl = Globals.CheckUrlRoot + "-$version/Status/"
		proj = "src/service/app/app.csproj"
		name, output, _ = GetBuildConfig(Globals, proj)

		bin = FileSet("**/$name.dll", BaseDirectory: output).First()
		assembly = AssemblyDefinition.ReadAssembly(bin)
		version = assembly.Name.Version.ToString()
		done = false
		count = 0
		while not done:
			try:
				count++
				if count > 20:
					raise "Не удалось дождаться версии $version"
				using client = WebClient():
					client.Credentials = NetworkCredential(testId, testPassword)
					serviceVersion = client.DownloadString(Globals.CheckUrl)
					done = serviceVersion == version
				unless done:
					print "Для сервиса ${Global.CheckUrl} ожидаю версию $version получил $serviceVersion"
					print "Жду обновления"
					Thread.Sleep(1000)
			except e:
				if count > 20:
					raise
				print e.Message
				print "Жду обновления"
				Thread.Sleep(1000)
		Db.Execute("update Customers.AnalitFNetDatas set BinUpdateChannel = 'alpha' where UserId = $testId")
		Sh("nunit-console-x86 /nologo /run test.release.AppFixture ./src/client/test.release/bin/Debug/test.release.dll")
		CopyUpdateBin("beta")
		if Globals.Maybe.SetupDeployRoot:
			dst = Path.Combine(Globals.Maybe.SetupDeployRoot, "AnalitF.Net-$version.exe")
			Cp("output/setup/setup.exe", dst)
	except:
		print "Похоже что есть проблемы с релизом, автоматическое обновление отключено, исправь ошибки и повтори релиз, возможно следует удалить тег релиза"
		raise

task "deploy:announce":
	unless Globals.Environment == @Production:
		raise "Задача может быть выполнена только в среде Production задай env=Production"
	url = "http://redmine.analit.net/projects/afn"
	version = File.ReadAllText("output/setup/version.txt")
	setupBin = Path.Combine(Globals.SetupDeployRoot, "AnalitF.Net-$version.exe")
	client = WebClient()
	client.Encoding = Encoding.UTF8
	client.Headers.Add(HttpRequestHeader.ContentType, "application/json")
	client.Headers.Add("X-Redmine-API-Key", "778ed542c36c919a58c9fa62615e3096b0761a42")
	redmineVersion = JsonConvert.DeserializeObject(client.UploadString("$url/versions.json", "{ \"version\": {\"name\": \"$version\" } }"))
	redmineVersionId = redmineVersion[@version][@id].ToString()

	subject = "Версия $version"
	description = """"Установщик":http://ios.analit.net/Files/AnalitF.Net-$version.exe
"Список изменений":http://redmine.analit.net/versions/${redmineVersionId}
"""
	content = JsonConvert.SerializeXNode(XElement("issue", XElement("subject", subject), XElement("description", description)))
	client = WebClient()
	client.Encoding = Encoding.UTF8
	client.Headers.Add(HttpRequestHeader.ContentType, "application/json")
	client.Headers.Add("X-Redmine-API-Key", "778ed542c36c919a58c9fa62615e3096b0761a42")
	client.UploadString("$url/issues.json", content)
	setupBin = Path.Combine(Globals.SetupDeployRoot, "AnalitF.Net-$version.exe")
	Cp(setupBin, """\\adc.analit.net\Inforoom\FTP\anonymous\""", true)

task "deploy:setup":
	unless Globals.Environment == @Production:
		raise "Задача может быть выполнена только в среде Production задай env=Production"
	version = File.ReadAllText("output/setup/version.txt")
	setupBin = Path.Combine(Globals.SetupDeployRoot, "AnalitF.Net-$version.exe")
	Cp(setupBin, """\\adc.analit.net\Inforoom\FTP\anonymous\AnalitFNET_0_9_0_28.exe""", true)
	Cp(setupBin, """\\adc.analit.net\Inforoom\FTP\anonymous\AnalitFNET.exe""", true)
	CopyUpdateBin("rtm")

task "iis:clean":
	iishost = Globals.IISHost
	hosts = iishost as ICollection or (iishost, )
	sitename = Globals.IISSiteName
	hostsArg = join(hosts, ",")
	psArgs = ""
	if Globals.Environment == @Production:
		user, password = AskCredentials("user for $hostsArg:")
		psArgs = "-Credential (New-Object PsCredential('$user', (convertto-securestring '$password' -asplaintext -force)))"
	Exec("powershell", "Invoke-Command -ComputerName $hostsArg $psArgs -ScriptBlock {Remove-WebApplication -site $sitename Analitf.Net.Proxy}").Execute()
	Exec("powershell", "Invoke-Command -ComputerName $hostsArg $psArgs -ScriptBlock {Remove-WebApplication -site $sitename AnalitF.Net.Service-0.9.7.35}").Execute()

task "db:local:seed":
	Bash("rym -f Rymfile.service fixture execute SampleData")
