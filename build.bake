import System
import System.Collections
import System.Reflection
import System.IO
import System.Net.Mail
import System.Xml
import System.Xml.Linq
import System.Linq.Enumerable
import System.Xml.XPath.Extensions
import System.Net
import System.Text
import System.Threading
import Mono.Cecil
import Microsoft.Web.Administration from "Microsoft.Web.Administration, Version=7.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"

def FileElement(file as string, id as string, element as XElement):
	return XElement(element.Name.Namespace + "File", XAttribute("Id", id), XAttribute("Source", Path.GetFullPath(file)))

def AddDirectory(id as string, path as string, document as XDocument, manager as XmlNamespaceManager):
	element = document.XPathSelectElement("/prefix:Wix/prefix:Fragment/prefix:DirectoryRef[@Id='$id']/prefix:Component", manager)
	for file in Directory.GetFiles(path):
		fileId = Path.GetFileName(file) + "_" + id
		element.Add(FileElement(file, fileId, element))

	for dir in Directory.GetDirectories(path):
		id = Path.GetFileName(dir)
		AddDirectory(id, dir, document, manager)

def RegisterApp(iishost as object, sitename as string, path as string, fspath as string):
	hosts = iishost as ICollection or (iishost, )
	for host in hosts:
		manager = ServerManager.OpenRemote(host)
		site = manager.Sites[sitename]
		raise "Не могу найте сайт $sitename" unless site
		app = site.Applications.FirstOrDefault({a| a.Path == "/" + path})
		return if app
		app = site.Applications.Add("/" + path, fspath)
		config = manager.GetApplicationHostConfiguration()
		section = config.GetSection("system.webServer/security/authentication/anonymousAuthentication", "$sitename/$path")
		section[@enabled] = false
		section = config.GetSection("system.webServer/security/authentication/basicAuthentication", "$sitename/$path")
		section[@enabled] = true
		section[@realm] = "adc.analit.net"
		section[@defaultLogonDomain] = "adc.analit.net"
		manager.CommitChanges()

Global(
#	Project: "src/service/app/app.csproj",
	HumanReadableName: "AnalitF.Net",
	Profile: @catalog,
	Variables : {
		@Local: {
			@UpdateDeployRoot: """C:\inetpub\wwwroot\AnalitF.Net.Service-0.9.7.35\var\update\rtm""",
			@CheckUrlRoot: "http://localhost/AnalitF.Net.Service",
			@IISSiteName: "local",
			@IISHost: "localhost"
		},
		@Production : {
			@UpdateDeployRoot: """\\acdcserv\WebApps\var\update\alpha""",
			@CheckUrlRoot: "http://test.analit.net/AnalitF.Net.Service",
			@IISSiteName: "IOS",
			@IISHost: ("acdcserv", "solo", "frontrmt")
		},
		@Test : {
			@DeployRoot: """\\acdcserv\TEST""",
			@DeployAlias: "AnalitF.Net.Service.Test",
			@UpdateDeployRoot: """\\acdcserv\TEST\var-test\update\rtm""",
			@CheckUrlRoot: "http://test.analit.net/AnalitF.Net.Service",
			@IISSiteName: "TEST",
			@IISHost: "acdcserv"
		}
	},
	JenkinsProject: "AnalitF.Net",
	Retarget: true
)

task @default, [@build]

task @build, ["build:service", "build:client"]

task @prepare, ["env", "packages:install", "packages:fix", "generate:assembly:info"]

task "build:service", ["prepare"]:
	CleanWeb(Globals, "src/service/app/app.csproj")
	BuildWeb(Globals, "src/service/app/app.csproj")

task "deploy:service", ["build:service"]:
	proj = "src/service/app/app.csproj"
	name, output, _ = GetBuildConfig(Globals, proj)

	bin = FileSet("**/$name.dll", BaseDirectory: output).First()
	assembly = AssemblyDefinition.ReadAssembly(bin)
	version = assembly.Name.Version.ToString()

	deployTo = GetDeploy(Globals, proj)
	deployTo += "-$version"
	Globals.CheckUrl = Globals.CheckUrlRoot + "-$version/Main/Version"
	MkDir(deployTo) unless Exist(deployTo)
	deployToBin = Path.Combine(deployTo, "bin")
	deployToVar = Path.Combine(deployTo, "var")
	MkDir(deployToBin) unless Exist(deployToBin)
	MkDir(deployToVar) unless Exist(deployToVar)
	XCopyDeploy(Globals, "src/service/app/app.csproj", deployToBin)
	RegisterApp(Globals.IISHost, Globals.IISSiteName, Path.GetFileName(deployTo), Path.GetFullPath(deployToBin))

	#создаем маршрут в прокси
	proj = "src/proxy/app/app.csproj"
	deployTo = Path.Combine(GetDeploy(Globals, proj), "bin")
	proxyConfig = Path.Combine(deployTo, @config)
	webConfigInfo = FileInfo(Path.Combine(deployTo, "Web.Config"))
	unless webConfigInfo.Exists:
		raise "Не удалось найти конфигурационный файл прокси ${webConfigInfo.FullName}, прокси должен быть развернут первым вызови bake deploy:proxy"
	webConfigInfo.LastWriteTime = DateTime.Now
	using writer = StreamWriter(proxyConfig, true):
		writer.WriteLine("$version " + Globals.CheckUrlRoot + "-$version")

task "build:proxy", ["prepare"]:
	CleanWeb(Globals, "src/proxy/app/app.csproj")
	BuildWeb(Globals, "src/proxy/app/app.csproj")

task "deploy:proxy", ["build:proxy"]:
	proj = "src/proxy/app/app.csproj"
	name, output, _ = GetBuildConfig(Globals, proj)
	deployTo = GetDeploy(Globals, proj)
	deployToBin = Path.Combine(deployTo, "bin")
	XCopyDeploy(Globals, proj, deployToBin)
	RegisterApp(Globals.IISHost, Globals.IISSiteName, Path.GetFileName(deployTo), Path.GetFullPath(deployToBin))

task @deploy, ["env", "git:tag", "prepare", "check", "build", "db:migrate", "deploy:service", "deploy:client", "deploy:update", "test:binary", "deploy:notify", "git:push:tags"]

task "deploy:client", ["deploy:client:package"]

task "deploy:client:package", ["build:client:package"]:
	impersonate = Configuration.Maybe.impersonate != null
	if impersonate:
		ImpersonateUser("deployer", '$sdfsd887!'):
			Cp("output/package/*.nupkg", "//offdc/MMedia/packages", true)
	else:
		Cp("output/package/*.nupkg", "//offdc/MMedia/packages", true)

task "build:client:package", ["build:client"]:
	proj = "src/client/app/app.csproj"
	name, output, _ = GetBuildConfig(Globals, proj)
	bin = FileSet("*.exe", BaseDirectory: output).First()

	assembly = AssemblyDefinition.ReadAssembly(bin)
	version = assembly.Name.Version.ToString()
	build = Configuration.Maybe.buildId
	if build:
		version += "-build" + build
	RmDir("output/package", true)
	MkDir("output/package")
	MkDir("output/package/tools")
	Cp("output/setup/setup.exe", "output/package/tools/analitf.net.setup.exe", true)
	Cp(FileSet("**.*", BaseDirectory: output), "output/package/tools/", true)
	spec = "output/package/analitf.net.nuspec"
	Cp("assets/package.nuspec", spec)
	specDoc = XDocument.Load(spec)
	versionNode = specDoc.Descendants().First({n| n.Name.LocalName == "version"})
	versionNode.Value = version
	specDoc.Save(spec)
	Exec("cmd.exe", "/C choco pack", BaseDirectory: "output/package").Execute()

task "deploy:update", ["build:client"]:
	dir = Globals.UpdateDeployRoot
	if Exist(dir):
		Rm("$dir/*")
	else:
		MkDir(dir)
	impersonate = Configuration.Maybe.impersonate != null
	if impersonate:
		ImpersonateUser("deployer", '$sdfsd887!'):
			Cp("output/updater/*", dir, true)
	else:
		Cp("output/updater/*", dir, true)

task "build:client", ["env", "build:client:bin", "build:setup", "build:update"]

task "build:client:bin":
	proj = "src/client/app/app.csproj"
	name, output, _ = GetBuildConfig(Globals, proj)
	Clean(Globals, proj)
	Build(Globals, proj)
	Cp(FileSet("**", BaseDirectory: "lib/libmysqld", Excludes: ["build.sh", ".gitignore"]), output)
	Rm(FileSet("$output/*.xml"))
	if Globals.Environment == @Production:
		Rm(FileSet("$output/*.pdb"))

task "build:setup":
	arg = ""
	if Globals.Environment != @Production:
		arg = "--quiet"
	Bash("./scripts/wix.sh $arg")

task "setup:preprocess":
	proj = "src/client/app/app.csproj"
	name, output, _ = GetBuildConfig(Globals, proj)
	bin = FileSet("*.exe", BaseDirectory: output).First()

	assembly = AssemblyDefinition.ReadAssembly(bin)
	File.WriteAllText("output/setup/version.txt", assembly.Name.Version.ToString())
	name = "output/setup/files.wxs"
	document = XDocument.Load(name)
	manager = XmlNamespaceManager(NameTable())
	manager.AddNamespace("prefix", "http://schemas.microsoft.com/wix/2006/wi")

	AddDirectory("INSTALLFOLDER", output, document, manager)
	document.Save(name)
	Cp("assets/Демонстрационная дефектура.csv", "output/setup/")

task "build:update":
	_, clientOutput, _ = GetBuildConfig(Globals, "src/client/app/app.csproj")
	_, updaterOutput, _ = GetBuildConfig(Globals, "src/updater/app/app.csproj")
	Clean(Globals, "src/updater/app/app.csproj")
	Build(Globals, "src/updater/app/app.csproj")
	Cp("output/setup/version.txt", updaterOutput, true)
	Cp("$clientOutput/*", updaterOutput, true)
	Rm(FileSet("$updaterOutput/*.xml"))
	if Globals.Environment == @Production:
		Rm(FileSet("$updaterOutput/*.pdb"))

task "git:push:tags":
	return unless Globals.Environment == @Production
	Bash("git push --tags")

task "git:tag":
	return unless Globals.Environment == @Production
	kind = Configuration.Maybe.kind
	raise "Нужно указать тип релиза kind=patch - исправление ошибок, kind=minor - новый функционал, kind=major - координальные изменения в существующем функционале" unless kind
	Bash("./scripts/tag-release.sh $kind")

task "test:binary":
	return unless Globals.Environment == @Production
	try:
		if Globals.CheckUrl:
			proj = "src/service/app/app.csproj"
			name, output, _ = GetBuildConfig(Globals, proj)

			bin = FileSet("**/$name.dll", BaseDirectory: output).First()
			assembly = AssemblyDefinition.ReadAssembly(bin)
			version = assembly.Name.Version.ToString()
			done = false
			while not done:
				try:
					serviceVersion = WebClient.DownloadString(Globals.CheckUrl)
					done = serviceVersion == version
					unless done:
						print "Версия сервиса $serviceVersion жду $version"
						print "Жду обновления"
						Thread.Sleep(1000)
				except e:
					print e.Message
					print "Жду обновления"
					Thread.Sleep(1000)
		testId = 26307
		Db.Execute("update Customers.AnalitFNetDatas set BinUpdateChannel = 'alpha' where UserId = $testId")
		Sh("nunit-console-x86 /nologo /run test.release.AppFixture ./src/client/test.release/bin/Debug/test.release.dll")
		dir = Path.Combine(Path.GetDirectoryName(Globals.UpdateDeployRoot), "beta")
		if Exist(dir):
			Rm("$dir/*")
		else:
			MkDir(dir)
		impersonate = Configuration.Maybe.impersonate != null
		if impersonate:
			ImpersonateUser("deployer", '$sdfsd887!'):
				Cp("output/updater/*", dir, true)
		else:
			Cp("output/updater/*", dir, true)
	except:
		print "Похоже что есть проблемы с релизом, автоматическое обновление отключено, исправь ошибки и повтори релиз, возможно следует удалить тег релиза"
		raise

task "deploy:setup":
	url = "http://redmine.analit.net/projects/afn/versions.json"
	version = File.ReadAllText("output/setup/version.txt")
	client = WebClient()
	client.Headers.Add(HttpRequestHeader.ContentType, "application/json")
	client.Headers.Add("X-Redmine-API-Key", "778ed542c36c919a58c9fa62615e3096b0761a42")
	try:
		client.UploadString(url, "{ \"version\": {\"name\": \"$version\" } }")
	except e:
		print e
	Cp("output/setup/setup.exe", """\\adc.analit.net\Inforoom\FTP\anonymous\AnalitFNET_0_9_0_28.exe""", true)
	Cp("output/setup/setup.exe", """\\adc.analit.net\Inforoom\FTP\anonymous\AnalitFNET.exe""", true)
